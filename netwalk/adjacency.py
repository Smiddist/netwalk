# determining adjacent tiles efficiently
import numpy as np

class tiling_adjacencies(object):
    """
    The set (with repeats) of all adjacencies of a tileset. An adjacency
    is an interface
    """
    def __init__(self, tset):
        self.__parent__ = tset
        self.interfaces = interface_set(self)
        self.adjacencies = self.generate_adjacencies()
        return

    def generate_adjacencies(self):
        """
        The set of all ``adjacency`` objects, i.e. the set with one
        ``adjacency`` per tile for all tiles in a ``tileset``. The
        ``adjacencies`` is generated by convolving a filter of row lengths
        [1,2,1] over an expanded form of the n by 2n ``interface_set`` grid
        (which is augmented by appending the 0th row to the rows, and the
        0th element of each row at the end of the same row, i.e. as an extra
        column). This expanded form of the grid is implemented as an integer-
        valued index, whose values index the interfaces grid, and is finally
        converted to actual references after the 2D sliding window produces
        an n by n array again (so as to avoid making copies of interfaces).
        """
        n = len(self.__parent__.tiles)
        index_grid = np.arange(len(self.interfaces.interfaces)).reshape(2*n,n)
        index_grid = np.array([np.hstack([x, x[0]]) for x in index_grid])
        index_grid = np.vstack([index_grid, index_grid[0]])
        adj_filter = np.array([[1,0],[1,1],[1,0]], dtype=bool)
        af_ind = np.argwhere(adj_filter.flat).ravel()
        adj_subarr = []
        for j in np.arange(2*n)[::2]:
            for i in np.arange(n):
                adj_subarr.append(index_grid[j:j+3,i:i+2].flat[af_ind])
        # permute to clockwise order before initialising ``adjacency``
        adj = [adjacency(x[[0,2,3,1]], self) for x in adj_subarr]
        return adj

    def __repr__(self):
        # TODO
        return "(Adjacencies)"

class adjacency(object):
    """
    A vector of four, separate, directional ``adjacence`` instances of a
    given tile, i.e. a clockwise vector of ``interface`` references,
    which represent the shared interfaces along a tile's four edges.
    """
    def __init__(self, vec: np.ndarray, parent: tiling_adjacencies):
        assert vec.shape == (4,)
        self.__parent__ = parent
        self.interface_index = vec # expect directions be clockwise from top
        self.adj = [self.get_adjacence(a) for a in np.arange(4)]
        return

    def get_adjacence(self, a: np.typeDict['int']):
        """
        Get a single adjacence, for the direction (0-3) indicated by ``a``.
        """
        return adjacence(a, self.__parent__, self.interface_index[a])

    def __repr__(self):
        r_top_line = []
        r_bottom_line = []
        for l in [self.adj[x].interface for x in np.arange(4)]:
            for (i, s) in enumerate(l.__repr__().split('\n')):
                assert i < 2
                if len(l.__repr__().split('\n')) == 1:
                    r_top_line.append(' ' * len(s))
                    r_bottom_line.append(s)
                else:
                    if i == 0:
                        r_top_line.append(s)
                    else:
                        r_bottom_line.append(s)
        return f"{' | '.join(r_top_line)}\n{' | '.join(r_bottom_line)}"

class adjacence(object):
    """
    A single directional adjacence, containing [a reference to] a single
    interface object (which belongs to the interface set of the tileset).
    """
    def __init__(self, a: np.typeDict['int'], A: tiling_adjacencies, \
                 i: np.typeDict['int']):
        self.direction = a
        self.__parent__ = A
        self.interface_index = i
        self._interface = self.get_interface(self.interface_index)
        return

    def __repr__(self):
        # TODO: won't need to print this, ``adjacency`` has a nice __repr__
        return f"Adjacence (interface {self.interface_index} : {self.direction})"

    @property
    def interface(self):
        return self._interface

    def get_interface(self, i: np.typeDict['int']):
        return self.__parent__.interfaces.interfaces[i]

class interface(object):
    """
    The edge shared by two tiles is an 'interface'. Each interface has an
    'address' in the form of an integer in ``range(0, (n)*(2*n))``, i.e.
    the count of each element of an n by 2n array. The ``before`` attribute
    indicates the left/upper tile (depending on whether the interface in
    question is horizontal/vertical) and ``after`` indicates its complement.
    """
    def __init__(self, i: np.typeDict['int'], tset):
        self.__tileset__ = tset
        self.index = i
        self.horizontal = self.is_horizontal()
        self._pre = None
        self._post = None
        self.map_pre_post()
        return

    def __repr__(self):
        if self.horizontal:
            return f"{self.pre!r}\n{self.post!r}"
        else:
            return f"{self.pre!r}::{self.post!r}"

    def is_horizontal(self):
        n = len(self.__tileset__.tiles)
        return self.index % (2*n) < n

    def map_pre_post(self):
        """
        Initialise interface tile references.
        """
        self.map_pre()
        self.map_post()
        assert None not in (self.pre, self.post)
        return

    @property
    def pre(self):
        return self._pre

    @pre.setter
    def pre(self, val):
        self._pre = val
        return

    @property
    def post(self):
        return self._post

    @post.setter
    def post(self, val):
        self._post = val
        return

    def map_pre(self):
        """
        Set adjacent tile 'before' an interface edge (upper/left).
        """
        if self.horizontal:
            self.pre = self.get_adjacent_tile(self.__tileset__, 0)
        else:
            self.pre = self.get_adjacent_tile(self.__tileset__, 3)
        return

    def map_post(self):
        """
        Set adjacent tile 'after' an interface edge (below/right).
        """
        if self.horizontal:
            self.post = self.get_adjacent_tile(self.__tileset__, 2)
        else:
            self.post = self.get_adjacent_tile(self.__tileset__, 1)
        return

    def get_adjacent_tile(self, tset, a: int):
        """
        Handle the retrieval of tiles from the parent tileset, including
        edge wrapping logic using the index of the interface. Note that
        the edge logic applies to the n by 2n interface set, not to the
        tileset, which simplifies the task of handling edge wrapping.
        """
        assert self.horizontal == (a % 2 == 0) and 0 <= a < 4
        n = len(tset.tiles)
        i = self.index.view()
        if a == 0 and i < n:
            # tile is on the top edge of tileset, so edge wraps
            return tset.tiles[-1][i]
        elif a == 1 and i % n == (n-1):
            # tile is on the right edge of tileset, so edge wraps
            return tset.tiles[int((i + 1) / (2*n))-1][0]
        # N.B. a=2 on the bottom edge does not need to be handled,
        # as interfaces on the bottom row are vertical only
        elif a == 3 and i % n == 0:
            # tile is on the left edge of tileset, so edge wraps
            return tset.tiles[int(((i / n)-1) / 2)][-1]
        else:
            # the adjacent tile does not cross tileset outer edge
            if self.horizontal:
                if a == 2:
                    # decrement the interface index by n per row to
                    # retrieve the corresponding tileset index t_i
                    t_i = int(((i - (i % n))/2) + (i % n))
                    return tset.tiles[int((t_i - (t_i % n)) / n)][t_i % n]
                else:
                    # a == 0 so as for a == 2, but also decrement i by 2n
                    # (the 0th row was removed by the ``i < n`` test)
                    # TODO: multistep: subtract ``(step-1)*n``, default step=1
                    t_i = int(((i - 2*n - (i % n))/2) + (i % n))
                    return tset.tiles[int((t_i - (t_i % n)) / n)][t_i % n]
            else:
                if a == 1:
                    # as for a == 2, but decrement n to 0-base the 1st row
                    t_i = int(((i - n - (i % n))/2) + (i % n))
                    return tset.tiles[int((t_i - (t_i % n)) / n)][t_i % n]
                else:
                    # a == 3 so as for a == 1, but also decrement the row
                    # offset (i.e. modulus remainder) by 1 (the 0th column
                    # was removed by the ``i % n == 0`` test)
                    t_i = int(((i - n - (i % n))/2) + (i % n) - 1)
                    return tset.tiles[int((t_i - (t_i % n)) / n)][t_i % n]

class interface_set(object):
    """
    The set (without repeats) of all interfaces of a tileset. A
    tileset of dimensions n by n will have ``interface_set`` dimensions
    of [width] n by [height] 2n. N.B. the interface set is NOT the set
    of all edges, which has repeated elements (and is therefore
    implemented in ``tiling_adjacencies``, with integers indexing the
    reference elements of the ``interface_set``).
    """
    def __init__(self, adj: tiling_adjacencies):
        self.__parent__ = adj
        self.__tileset__ = adj.__parent__
        self._interfaces = []
        self.generate_interfaces()
        return

    def __repr__(self):
        rep = []
        n = len(self.__tileset__.tiles)
        for (i, r) in enumerate(np.arange(n*2*n).reshape((2*n,n))):
            s = int(i < 10) * ' '
            o = int(i*n < 10) * ' '
            if i % 2 == 0:
                s += f'{i}: {o}{i*n} ' + ' '.join(['â€“']*n) + f' {((i+1)*n)-1}'
            else:
                s += f'{i}: {o}{i*n} ' + ' '.join(['|']*n) + f' {((i+1)*n)-1}'
            rep.append(s)
        return '\n'.join(rep)

    @property
    def interfaces(self):
        return self._interfaces

    @interfaces.setter
    def interfaces(self, val: list):
        self._interfaces = val
        return

    def generate_interfaces(self):
        assert len(self.interfaces) == 0 # only used upon initialisation
        self.interfaces = generate_tile_interfaces(self.__tileset__)
        return

def generate_tile_interfaces(tset) -> list:
    """
    Using the ``tiles`` [attribute] from a ``tileset``, i.e. a list of
    rows of ``tile`` instances, produce the full set of interfaces.
    """
    n = len(tset.tiles)
    interface_index = np.array(np.arange(n*2*n)).reshape(2*n,n)
    interfaces = [interface(i, tset) for i in interface_index.flat]
    return interfaces
